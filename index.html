<!DOCTYPE html>
<html>
    <head>
        <title>PLANTS HUMANS ROBOTS</title>
        <meta charset="utf-8">
    
        <!-- >>>>>STYLESHEETS<<<<< -->
        <link href="css_reset.css" rel="stylesheet" type="text/css">
        <link href="plants-vs-humans.css" rel="stylesheet" type="text/css">

        <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Oswald:regular&amp;subset=latin"/>
        <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Arvo:regular&amp;subset=latin"/>
            
        <!-- >>>>>BOOTSTRAP SCRIPTS<<<<< -->
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="https://code.jquery.com/jquery.js"></script>
            
        <!-- >>>>>D3 SCRIPTS<<<<< -->
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
        <script type="text/javascript" src="d3/d3.min.js"></script>

    </head>
    <body>
        <div id="gmuArt">
            <div id="website">
                <div id="header">
                    <h3 class="title">PLANTS vs HUMANS</h3>
                </div>
                
                <div id="content_text">
                    <article>
                        <h3>Die Natur in der Technik oder die Technik in der Natur.</h3>
                        <br>
                        <hr class="shadow"/>
                        <br>

                        <p>In meinem Uni-Projekt "PLANTS vs HUMANS" ist ein kleines Chrome-Plugin entstanden, welches einen künstlichen Baum über den Bildschirm wachsen lässt. Ein künstlicher Baum, der die Nutzer davon abhält eine Webseite sinnvoll zu bedienen. Ein künstlicher Baum, der nichts nützt und trotzdem interessant ist. Er ist nicht interessant weil er stört, sondern aufgrund seines Wachstums und der daraus resultierenden Form. Eine Form die vielen Formen in der Natur in gewisserweise sehr ähnlich ist, da sie nach dem gleichen Prinzip entsteht. Ein Prinzip das sich in den Wolken, in Schneeflocken, an der Küste, in den Bergen, in Pflanzen – überall – wiederfinden lässt.</p>

                        <p>Rekursion – Ein Phänomen, dass sich überall in der Natur finden lässt und oftmals nur unterbewusst bewundert wird, weil wir das Muster nicht in seinem gesamten Ausmaß erkennen. Das Phänomen, dass Formen sich wiederholen, dass Formen sich in sich selbst spiegeln, dass Formen aus sich selbst bestehen. Die Einfachheit und die Genialität der Rekursion verschließt sich dem Auge meist in einer komplexen Vielfalt an Formen, die man erst nach längerem Beobachten durchdringt. In manchen Dingen ist sie leichter zu entdecken als in anderen. 
                        Es fällt uns beispielsweise schwer genauer zu beschreiben, wie die Struktur eines Baumes oder eines Blumenkohls entsteht. Eine gewisse Ähnlichkeit zwischen beiden Pflanzen ist jedoch nicht von der Hand zu weisen und lässt uns schließen, dass ähnliche "Prozesse" statt finden. Bei Farnblättern hingegen ist das Prinzip der Rekursion leichter zu erfassen. Dort scheinen immer kleinere Kopien des Blattes selbst an dem Blatt zu hängen, nur um ~90° gedreht. Das Farnblatt wird in sich wiederholenden Schritten aus einer einfachen Grundform aufgebaut. Hat man diese Grundlage der Rekursion einmal erkannt, so findet man sie auch beim Blumenkohl wieder, nur mit einer anderen Form. Der Blumenkohl erweckt den Eindruck als bestehe er aus vielen kleinen Blumenkohlen, und diese wieder aus vielen kleinen... bis es irgendwann nicht mehr kleiner geht. In diesem Fall hat man die maximale Rekursionstiefe erreicht.</p>
                        <p>In der Mathematik werden solche geometrischen Formen, die sich selbstbeinhalten, als Fraktale bezeichnet.</p>

                        <div class="text_imgs" style="width:700px;">
                            <img class="picture" id="farn" src="imgs/farn.jpg" height="300px">
                            <img class="picture" id="kohl" src="imgs/kohl.jpg" height="300px">
                        </div>
                        <br>
                        <hr class="shadow"/>
                        <br>

                        <p>Bei Bäumen sind diese rekursiven Fraktale ebenfalls vorhanden, nur etwas komplizierter, weil sie mehrere Grundformen beinhalten und komplexeren Regeln folgen. Um den Baum etwas zu vereinfachen könnte man ihn beispielsweise auf drei Formen reduzieren: dicke und dünne Äste, sowie Blätter. Diese Formen treten am Baum nur in bestimmten Reihenfolgen auf. Wenn man einige Beoachtungen anstellt, könnte man einige Tatsachen festhalten, wie zum Beispiel die Folgenden:</p>

                        <p> - Blätter wachsen nie an dicken Ästen.</p>
                        <p> - Dicke Äste wachsen nicht an dünnen Ästen.</p>
                        <p> - Aus dünnen Ästen werden nach einiger Zeit dicke Äste.</p>
                        <p>usw.</p>
                        <br>
                        <p>Aus einigen dieser Sätze lassen sich im Anschluss sogar Regeln oder Grammatiken formulieren, welche dann auf sehr formale Weise einen Baum (oder andere Dinge in der Natur) beschreiben. Wenn man diese Grammatiken in einen Computer hineingibt, so kann der Computer eine Abbildung des Baumes ableiten. Das interessante dabei ist, dass die Abbildung des Computers nicht unbedingt eine maximale Rekursionstiefe braucht. Was dazu führt, dass man immer tiefer in die Abbildung hineintauchen kann.
                        Beim hineintauchen wird man feststellen, dass sich das Computerfraktal gar nicht verändert, sondern nur wir unsere Position im Fraktal.</p>
                        <br>
                        <div class="text_imgs" style="width:560px;">
                            <img id="pythagoras" src="imgs/pythagoras.png" width="550px">
                        </div>
                        <br>
                        <p>In der Informatik bezeichnet man diese Grammatiken als Lindenmayer-Systeme und es ist erstaunlich was für beeindruckende Fraktale sie erzeugen können und wie viele dieser Fraktale man in der Natur wiederfindet, so ähnelt der Pythagorasbaum beispielsweise sehr der Form eines Blumekohl oder Brokkoli.</p>

                        <p>Oft reichen schon wenige Regeln in einem L-System um ein relativ komplexes Fraktal zu bilden. Das kann an der Koch-Kurve sehr schön gezeigt werden. Bei ihr besitzen wir nur eine Form (F), zwei sogenannte Konstanten (+, -) und eine Regel  P={(F → F+F--F+F)}.</p>

                        <p><strong>F</strong> : Stellt eine Strich da, der in eine Richtung gezogen wird.</p>
                        <p><strong>+</strong> : Dreht den Strich um 60°  gegen den Uhrzeigersinn.</p>
                        <p><strong>-</strong> : Dreht den Strich um 60° mit dem Uhrzeigersinn.</p>
                        <br>
                        <div class="text_imgs" style="width:760px;">
                            <img class="picture" id="koch" src="imgs/koch_curve.png" width="750px">
                        </div>
                        <br>
                        <p>Unser Startwort ist F, was einem einfachen Strich entspricht. Nun beginnen wir unsere Regel P auf F anzuwenden. Wir ersetzten also F durch F+F--F+F. Schon nach wenigen Rekursivendurchgängen (Iterationen) erhalten wir ein Muster, dass sich immer wieder selbstenthält und mit dem Ursprung nur schwer in Verbindung gebracht werden. Erst wenn wir in unserem Muster nach sich wiederholenden Abschnitten ausschau halten, bemerken wir, dass jede Stufe die vorherige beinhaltet.
                        Bemerkenswert an Fraktalen ist, wie schwer es ist deren Ursprung zu ergründen, selbst wenn wir die Regeln kennen nach denen sie sich richten.</p> 
                        <br>
                        <div class="text_imgs" style="width:360px;">
                            <img class="picture" id="koch" src="imgs/flocke.png" width="350px">
                        </div>
                        <br>
                        <p>Diese Schneeflocke ist nach der gleichen Regel P erzeugt worden, wie oben unser kleines Beispiel. Sie beinhaltet ebenfalls nur F, + und - und die Regel P. Der einzige Unterschied liegt im Startwort. Kannst du das Startwort oder seine Form in dem Muster erkennen?
                        Ähnlich wie bei dieser Schneeflocke geht es uns überall in der Natur. Das Wissen um die Rekursion bietet uns eine neu Sichtweise auf unsere altbekannte Umwelt. Sie ermöglicht es uns nach den verborgenen Regeln der Natur zu suchen und die Magie in ihr zu finden.</p>

                        <p>Ob wir dabei jemals einen Ursprung finden werden bleibt offen</p>

                    </article>
                    <div id="content_tree">

                    </div>

                </div>
            </div>

            <div id="gmuGrid">
            </div>

            <div id="gmuPlant">
            </div>

            <script type="text/javascript">
            var mouse = {x: 0, y: 0};

            document.addEventListener('mousemove', function(e){ 
                mouse.x =  e.pageX; 
                mouse.y =  e.pageY; 
            }, false);

            // constants
            var padding = 10

            // variables
            var w = window.innerWidth - padding;
            //var h = window.innerHeight- padding;
            var body = document.body,
                html = document.documentElement;

            var h = Math.max( body.scrollHeight, body.offsetHeight, 
                              html.clientHeight, html.scrollHeight, html.offsetHeight );

            // grid variables/globals
            var cols = 0;
            var rows = 0;
            var rect_width = 1;
            var rect_height = 1;
            var rect_count = 50;
            var point_id  = 0;
            var rect_opacity = 0.2;

            var points = new Array();
            var grid_data = new Array();
            var hotspots = new Array();

            var color_scale = d3.scale.linear()
                .domain([0,14])
                .range(["#111111","green"]);

            var gridContainer = d3.select("#gmuGrid")
                .append("svg")
                .attr("width", w)
                .attr("height", h);
 
            // tendril variables/globals

            var grow_time = 2000;
            //var max_angle = Math.PI/7;
            var branch_length = 30;
            
            var global_tendril_count = 0;
            var global_tendril_id = 0;

            var last_angle = 0;
            var age_counter = 0;
            var branch_count = 0;
            
            var tendril_queue = new Array();
            var branch_queue = new Array();
            var plant_data = new Array();
            var age_queue = new Array();
            var draw_queue = new Array();

            var last_direction = { "x": 0,
                                   "y": 1}; 

            var artContainer = d3.select("#gmuPlant")
                .append("svg")
                .attr("width", w)
                .attr("height", h)
                .attr("z-index", 100)
                .attr("pointer-events", "none");

            // tree variables/globales    

            var tree_length = 60;
            var tree_branch_count = 0;
            var tree_queue = new Array();
            var tree_data = new Array();
            var treeContainer = d3.select("#content_tree")
                .append("svg")
                .attr("width", 1170)
                .attr("height", 700)
                .attr("z-index", 100)
                .attr("pointer-events", "none");

            var button = treeContainer
                .append("g")
                .attr("transform", function(d, i) { return "translate("+30+"," + 30 + ")"; });

                buttonRect = button.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 300)
                    .attr("height", 70)
                    .attr("fill", "#00ced1")
                    .attr("pointer-events", "all")
                    .on("mouseover",  function(d,i) {
                        buttonRect.transition()
                            .duration(30)
                            .attr("fill", "green");
                    })
                    .on("click",  function(d,i) {
                        buttonRect.transition()
                            .duration(30)
                            .attr("fill","green")
                        treeContainer.selectAll("path").remove()
                        tree_queue = new Array();
                        tree_data = new Array();
                        init_tree();
                        grow_tree(0,7);
                    })
                    .on("mouseout",  function(d,i) {
                        buttonRect.transition()
                            .duration(30)
                            .attr("fill", "#00ced1");
                    });

                button.append("text")
                    .attr("id","button_text")
                    .attr("x", 70)
                    .attr("y", 45)
                    .attr("pointer-events", "none")
                    //.attr("font", "30px")
                    //.attr("dy", "30px")
                    .text(function(d) { return "generate Tree"; });

            
            init_grid(300);
            draw_grid();

            init_tree();
            grow_tree(0,8);

            run_time_growth();

            //init_point_container();

            //######## Init functions   ########

            function init_grid(r_count){
                cols = Math.round(Math.sqrt(r_count * (w/h)));
                rows = Math.round(r_count / cols);

                rect_width = w / cols; // calc width of rects
                rect_height = h / rows; // calc height of rects

                var idx = 0;
                for(var r = 0; r < rows; r++){
                    for(var c = 0; c < cols ; c++){
                        grid_data[idx] = new Object();
                        grid_data[idx]["id"]      = idx;
                        grid_data[idx]["pos_x"]   = rect_width * c;
                        grid_data[idx]["pos_y"]   = rect_height * r;
                        grid_data[idx]["width"]   = rect_width;
                        grid_data[idx]["height"]  = rect_height;
                        grid_data[idx]["touched"] = 0;
                        grid_data[idx]["visited"] = 0;
                        idx++;
                    }
                }
            }

            function draw_grid(){

                var rectGrid = gridContainer.selectAll("rect")
                    .data(grid_data)
                    .enter()
                    .append("rect");

                rectGrid.attr("id", function(d,i){return "r"+i;})
                    .attr("x", function(d,i){return grid_data[i].pos_x})
                    .attr("y", function(d,i){return grid_data[i].pos_y})
                    .attr("width", function(d,i){return grid_data[i].width})
                    .attr("height", function(d,i){return grid_data[i].height})
                    .attr("fill", "#111111")
                    .attr("fill-opacity", rect_opacity)
                    .attr("stroke", "grey")
                    .attr("stroke-width", 1)
                    .attr("stroke-opacity", rect_opacity)
                    .style("pointer-events","auto")
                    .on("mouseover",  function(d,i) {
                        gridContainer.select("#r"+parseInt(d.id))
                                     .transition()
                                     .duration(70)
                                     .attr("fill","green")
                                     .attr("fill-opacity", rect_opacity);
                        update_hotspots(d.id);
                        if (grid_data[d.id].visited > 0){
                            gridContainer.select("#r"+parseInt(d.id))
                                     .transition()
                                     .duration(70)
                                     .attr("fill","red")
                                     .attr("fill-opacity", rect_opacity);
                        }

                    })
                    .on("mouseout",  function(d,i) {
                        gridContainer.select("#r"+parseInt(d.id))
                                     .transition()
                                     .duration(1000)
                                     .attr("fill",color_scale(d.touched))
                                     .attr("fill-opacity", rect_opacity);
                    })
            }

            function update_hotspots(id){
                if (typeof grid_data[id] != 'undefined') {
                    grid_data[id].touched++;
                
                    if(hotspots.indexOf(grid_data[id]) == -1){
                        hotspots.push(grid_data[id]);
                    }
                }
                //console.log("Hotspot Nr 1: ",hotspots[0]);
                //console.log("Hotspot Nr 2: ",hotspots[1]);
            }

            function sort_hotspots_by_touches(){
                // sort list - front most touched - back less touched
                hotspots.sort( function compare(a,b) {
                    if (a.touched > b.touched)
                        return -1;  
                    if (a.touched < b.touched)
                        return 1;
                    return 0;
                });
            }

            function run_time_growth(){
                var last_p = {"x": 0,
                              "y": 0};
                setInterval(function(){
                    var _p  = {"x": mouse.x,
                               "y": mouse.y };

                    points.push(_p);
                    last_p = _p
                    
                },grow_time/2);

                setInterval(function(){ 
                    sort_hotspots_by_touches();
                    if (points.length > 1){
                        if(branch_queue.length == 0){
                            if (global_tendril_id < 1){
                                var _start = { "x":1, 
                                               "y":h/3};
                                var _p = points.shift();
                                var _p2 = points.shift();
                                init_new_tendril(_start,_p,_p2);

                                var _start2 = { "x":w/1.5, 
                                                "y":1};

                                init_new_tendril(_start2,_p,_p2);
                            }
                        }
                        else{
                            idx = branch_queue.shift();
                            var _p = points.shift();
                            var _p2 = points.shift();
                            for (var i = 0; i < global_tendril_count; i++){
                                idx = tendril_queue.shift();
                                var _current_mouse_pos  = {"x": mouse.x,
                                                           "y": mouse.y };
                                if (plant_data[idx].tendril_number < 50){
                                    // create_next_tendril_random_mouse(plant_data[idx],
                                    //                                  _current_mouse_pos,
                                    //                                  _current_mouse_pos);
                                    create_next_tendril_hotspot_mouse(plant_data[idx],
                                                                     _current_mouse_pos,
                                                                     _current_mouse_pos);
                                } else {
                                    global_tendril_count--;
                                }
                            }

                            draw_branches(draw_queue, grow_time);
                        }
                    }
                    //console.log("start ageing")
                    start_ageing();
                }, grow_time);
            }

            function init_new_tendril(start, point, point2){
                var a = Math.PI / 4
                var _alpha = -Math.PI/2;
                var _start = start;  

                //middle point
                var _omega = get_min_max_angle(_start, _alpha, point, Math.PI/7);
                var _middle = { "x": _start.x + branch_length * Math.cos(_omega),
                                "y": _start.y + branch_length * Math.sin(_omega)};

                //end point
                _omega = get_min_max_angle(_middle, _omega, point2, Math.PI/7);
                var _end = { "x": _middle.x + branch_length * Math.cos(_omega), 
                             "y": _middle.y + branch_length * Math.sin(_omega)};
                
                last_direction = { "x": branch_length * Math.cos(_omega), 
                                   "y": branch_length * Math.sin(_omega)};

                var _root = new Array(_start,_middle,_end);

                plant_data[branch_count] = new Object();
                plant_data[branch_count]["id"] = branch_count;
                plant_data[branch_count]["tendril_id"] = global_tendril_id;
                plant_data[branch_count]["tendril_number"] = 0;
                plant_data[branch_count]["branch"] = _root;
                plant_data[branch_count]["angle"] = _omega;
                plant_data[branch_count]["wid"] = 8;
                plant_data[branch_count]["type"] = "ta";
                plant_data[branch_count]["generation"] = 0;
                plant_data[branch_count]["children"] = [];
                plant_data[branch_count]["parent"] = -1;

                global_tendril_id++;
                global_tendril_count++;

                tendril_queue.push(branch_count);
                branch_queue.push(branch_count);
                draw_branches([branch_count], 500);

                //draw_queue.push(branch_count);

                branch_count++;
            }

            function draw_branches(branch_list, time){
                //console.log("to draw: ", draw_queue, draw_queue.length)
                var _to_draw = branch_list.length;
                //console.log("Branchlist: ",branch_list)
                for (var i = 0; i < _to_draw; i++){

                    idx = branch_list.pop();
                    var plant_id = plant_data[idx].id;
                    //console.log("drawing", plant_id)
                    
                    //draw_queue.shift();
                    var lineFunction = d3.svg.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; })
                        .interpolate("cardinal");
                        //.interpolate("basis");
                        //.interpolate("cubic");
                        //bundle
                        //monotone
                    //console.log("drawing:", plant_data[idx].id)
                    var plantGraph = artContainer.append("path")
                        .attr("d", lineFunction(plant_data[idx].branch))
                        .attr("id", "p"+plant_data[idx].id)
                        .attr("stroke", "green")
                        .attr("pointer-events","stroke")
                        .attr("stroke-width", plant_data[idx].wid) //- (plant_data[idx].generation) * 0.4)
                        .attr("stroke-linecap", "round")  // stroke-linecap type
                        .attr("fill", "none")
                        .on("mouseover",  function(d,i) {
                            _id = this.id;
                            _id = _id.substr(1);
                            _id = parseInt(_id);

                            //console.log("NEW LEAF",_id);
                            if (global_tendril_count < 4){
                                var _start = plant_data[_id].branch[1];
                                var _p = {"x": randomIntFromInterval(0,w),
                                          "y": randomIntFromInterval(0,h)};
                                var _p2 = {"x": randomIntFromInterval(0,w),
                                           "y": randomIntFromInterval(0,h)};
                                //init_new_tendril(_start,_p,_p2);
                            }
                            //create_leaf(plant_data[_id], plant_data[_id].branch, plant_data[_id].angle, "lb");
                    });

                    var plant_length = plantGraph.node().getTotalLength();

                    plantGraph.attr("stroke-dasharray", plant_length + " " + plant_length)
                        .attr("stroke-dashoffset", plant_length)
                        .transition()
                            //.delay(plant_data[idx].generation * 3000)
                            .duration(time)
                            .ease("linear")
                            .attr("stroke-dashoffset", 0);

                    setTimeout(function(){
                        age_queue.push(age_counter);
                        age_counter++;
                    },6000);
                } 
            }

            function get_min_max_angle(ref_point, angle, new_point, max_angle){

                var _dir = { "x": ref_point.x + (branch_length * Math.cos(angle)),
                             "y": ref_point.y + (branch_length * Math.sin(angle))}; 

                var _a = {"x": _dir.x - ref_point.x,
                          "y": _dir.y - ref_point.y};

                var _b = {"x": new_point.x - ref_point.x,
                          "y": new_point.y - ref_point.y};
                
                var result_angle = dot_product(normalize_vec(_a),normalize_vec(_b));
                
                if (result_angle > 0.999999){
                    result_angle = 0.999999
                } else if (result_angle < -0.9999999){
                    result_angle = -0.9999999
                }
                result_angle = Math.acos(result_angle);

                if ( result_angle > max_angle){
                    result_angle = max_angle;
                }
                // check on which side the next point lies
                var _side = Math.sign((_dir.x-ref_point.x)*(new_point.y-ref_point.y) -
                                      (_dir.y-ref_point.y)*(new_point.x-ref_point.x));
                // adjust
                if (_side > 0){
                    result_angle = -result_angle;
                }
                result_angle = angle - result_angle;
                
                return result_angle;
            }

            function dot_product(a, b){

                var result = a.x * b.x + a.y * b.y
                return result
            }

            function normalize_vec(a){
                //console.log("norm a",a);
                _a_length = Math.sqrt((a.x) * (a.x) + (a.y) * (a.y));

                 a.x = (a.x) / _a_length;
                 a.y = (a.y) / _a_length;

                return a;
            }

            function create_next_tendril_random_mouse(object, point, point2){
                var new_child_id = branch_count;
                
                object.children.push(new_child_id);

                plant_data[new_child_id] = new Object();

                var _max_angle = Math.PI/5;
                var _old_end = plant_data[object.id].branch[2];
                var _old_mid = plant_data[object.id].branch[1];
                var _old_omega = plant_data[object.id].angle;

                var _start = _old_end;
                //get_next_hotspot_direction(_start);

                var _middle = get_next_grow_point(object.tendril_number + 1, _start, _old_omega, point, _max_angle);

                var _end = get_next_grow_point(object.tendril_number + 1, _middle, last_angle, point2, _max_angle);
                
                var _branch = new Array(_start, _middle,_end);

                plant_data[new_child_id]["id"] = new_child_id;
                plant_data[new_child_id]["tendril_id"] = object.tendril_id;
                plant_data[new_child_id]["tendril_number"] = object.tendril_number + 1;
                plant_data[new_child_id]["branch"] = _branch;
                plant_data[new_child_id]["angle"] = last_angle;
                plant_data[new_child_id]["wid"] = 7;
                plant_data[new_child_id]["type"] = "ta";
                plant_data[new_child_id]["generation"] = object.generation + 1;
                plant_data[new_child_id]["children"] = [];
                plant_data[new_child_id]["parent"] = object.id;

                branch_count++;

                //create fancy leaves for a nice look
                var _old_dir = { "x": branch_length * Math.cos(_old_omega),
                                 "y": branch_length * Math.sin(_old_omega)}; 
                var _new_dir = { "x": branch_length * Math.cos(last_angle),
                                 "y": branch_length * Math.sin(last_angle)};
                var check_angle = dot_product(normalize_vec(_old_dir),normalize_vec(_new_dir));
                check_angle = Math.acos(check_angle);
                console.log("angle:",check_angle);
                if(check_angle <0.1){
                    create_leaf(object, _branch, last_angle, "la");
                }else if(check_angle <0.3){
                    create_leaf(object, _branch, last_angle, "lb");
                }else if(check_angle >0.8){
                    create_leaf(object, _branch, last_angle, "lc");
                }else if(check_angle >0.6){
                    create_leaf(object, _branch, last_angle, "ld");
                }else {
                    // _leaf.push("c");
                }
                draw_queue.push(new_child_id);
                branch_queue.push(new_child_id);
                tendril_queue.push(new_child_id);
            }

            function create_next_tendril_hotspot_mouse(object, point, point2){
                var new_child_id = branch_count;
                
                object.children.push(new_child_id);

                plant_data[new_child_id] = new Object();

                var _max_angle = Math.PI/5;
                var _old_end = plant_data[object.id].branch[2];
                var _old_mid = plant_data[object.id].branch[1];
                var _old_omega = plant_data[object.id].angle;

                var _start = _old_end;

                // get rect old plant was in
                var _current_rect_id = get_rect_id_by_pos(_start);
                var _
                var _next_point = point;
                // get next hotspot to grow to
                var _hotspot_id = get_next_hotspot_id(_start);
                if (_hotspot_id == -1){
                    console.log("mouse")
                } else {
                    console.log("hotspot grow");
                    _next_point = get_random_point_on_rect(_hotspot_id);
                }

                var _middle = get_next_grow_point(1, _start, _old_omega, _next_point, _max_angle);

                if (_hotspot_id == -1){
                    console.log("mouse again");
                    _next_point = point2;
                } else {
                    console.log("hotspot grow again", _hotspot_id);
                    _next_point = get_random_point_on_rect(_hotspot_id);
                }

                var _end = get_next_grow_point(0, _middle, last_angle, _next_point, _max_angle);
                
                var _branch = new Array(_start, _middle,_end);
                // mark current rect as visited - to avoid growing over it again
                _current_rect_id = get_rect_id_by_pos(_end);
                grid_data[_current_rect_id].touched--;
                grid_data[_current_rect_id].visited++;

                plant_data[new_child_id]["id"] = new_child_id;
                plant_data[new_child_id]["tendril_id"] = object.tendril_id;
                plant_data[new_child_id]["tendril_number"] = object.tendril_number + 1;
                plant_data[new_child_id]["branch"] = _branch;
                plant_data[new_child_id]["angle"] = last_angle;
                plant_data[new_child_id]["wid"] = 7;
                plant_data[new_child_id]["type"] = "ta";
                plant_data[new_child_id]["generation"] = object.generation + 1;
                plant_data[new_child_id]["children"] = [];
                plant_data[new_child_id]["parent"] = object.id;

                branch_count++;

                //create fancy leaves for a nice look
                var _old_dir = { "x": branch_length * Math.cos(_old_omega),
                                 "y": branch_length * Math.sin(_old_omega)}; 
                var _new_dir = { "x": branch_length * Math.cos(last_angle),
                                 "y": branch_length * Math.sin(last_angle)};
                var check_angle = dot_product(normalize_vec(_old_dir),normalize_vec(_new_dir));
                check_angle = Math.acos(check_angle);
                //console.log("angle:",check_angle);
                if(check_angle <0.1){
                    create_leaf(object, _branch, last_angle, "la");
                }else if(check_angle <0.3){
                    create_leaf(object, _branch, last_angle, "lb");
                }else if(check_angle >0.8){
                    create_leaf(object, _branch, last_angle, "lc");
                }else if(check_angle >0.6){
                    create_leaf(object, _branch, last_angle, "ld");
                }else {
                    // _leaf.push("c");
                }
                draw_queue.push(new_child_id);
                branch_queue.push(new_child_id);
                tendril_queue.push(new_child_id);
            }

            function create_leaf(object, branch, middle_angle, type){
                var new_leaf_id = branch_count;
                //console.log("leaf id :",new_leaf_id);
                object.children.push(new_leaf_id);
                //new_child_id = object.children[0]
                plant_data[new_leaf_id] = new Object();

                var _old_end = branch[2];
                var _old_mid = plant_data[object.id].branch[1];
                var _old_start = plant_data[object.id].branch[0];
                var _old_omega = plant_data[object.id].angle;

                if (type == "la"){
                    console.log("a")
                    var _ran_point = {"x": randomIntFromInterval(0,w),
                                      "y": randomIntFromInterval(0,h)};
                    var _start = get_next_grow_point(new_leaf_id, _old_mid, middle_angle, _ran_point, Math.PI/8);
                    
                    _ran_point = {"x": randomIntFromInterval(0,w),
                                      "y": randomIntFromInterval(0,h)};
                    var _middle = get_next_grow_point(new_leaf_id, _start, last_angle, _ran_point, Math.PI/5);

                    _ran_point = {"x": randomIntFromInterval(0,w),
                                  "y": randomIntFromInterval(0,h)};
                    var _end = get_next_grow_point(new_leaf_id, _middle, last_angle, _ran_point, Math.PI/4);
                } else if (type == "lb" || type == "ld"){
                    console.log("b / d")
                    var _ran_point = {"x": randomIntFromInterval(0,w),
                                      "y": randomIntFromInterval(0,h)};
                    var _start = get_next_grow_point(new_leaf_id, _old_mid, middle_angle, _ran_point, Math.PI/10);
                    
                    _ran_point = {"x": randomIntFromInterval(0,w),
                                      "y": randomIntFromInterval(0,h)};
                    var _middle = get_next_grow_point(new_leaf_id, _start, last_angle, _ran_point, Math.PI/10);

                    _ran_point = {"x": randomIntFromInterval(0,w),
                                  "y": randomIntFromInterval(0,h)};
                    var _end = get_next_grow_point(new_leaf_id, _middle, last_angle, _ran_point, Math.PI/10);
                }else if (type == "lc"){
                    console.log("c")
                    var _ran_point = {"x": randomIntFromInterval(0,w),
                                      "y": randomIntFromInterval(0,h)};
                    var _start = get_next_grow_point(new_leaf_id, _old_start, middle_angle, _ran_point, Math.PI/6);
                    
                    _ran_point = {"x": randomIntFromInterval(0,w),
                                  "y": randomIntFromInterval(0,h)};
                    var _middle = get_next_grow_point(new_leaf_id, _start, last_angle, _ran_point, Math.PI/4);

                    _ran_point = {"x": randomIntFromInterval(0,w),
                                  "y": randomIntFromInterval(0,h)};
                    var _end = get_next_grow_point(new_leaf_id, _middle, last_angle, _ran_point, Math.PI/2);
                }
                var _branch = new Array(_old_mid, _start, _middle, _end);

                plant_data[new_leaf_id]["id"] = new_leaf_id;
                plant_data[new_leaf_id]["tendril_id"] = object.tendril_id;
                plant_data[new_leaf_id]["tendril_number"] = object.tendril_number;
                plant_data[new_leaf_id]["branch"] = _branch;
                plant_data[new_leaf_id]["angle"] = last_angle;
                plant_data[new_leaf_id]["wid"] = 3;
                plant_data[new_leaf_id]["type"] = type;
                plant_data[new_leaf_id]["generation"] = object.generation +1;
                plant_data[new_leaf_id]["children"] = [];
                plant_data[new_leaf_id]["parent"] = object.id;
                branch_count++;

                draw_queue.push(new_leaf_id);
            }

            function create_leaf_end(object, branch, middle_angle, type){
                // to do
                // make leafs end smaller 
            }

            function get_next_grow_point(tendril_id, start, old_angle, new_point, max_angle){
                //var _max_angle = Math.PI/5;
                var _omega = get_min_max_angle(start, old_angle, new_point, max_angle);

                var _dir = { "x": branch_length * Math.cos(_omega), //+ (Math.random() * 200) - 100,
                             "y": branch_length * Math.sin(_omega)}; 
                
                var _beta = get_random_angle_by_direction(tendril_id, _omega, _dir);
                
                _omega = (_omega + (_omega + _beta))/2;

                var _step_end = { "x": start.x + branch_length * Math.cos(_omega), //+ (Math.random() * 200) - 100,
                                  "y": start.y + branch_length * Math.sin(_omega)};
                //set the direction of middle as last_direction
                last_direction = {"x": branch_length * Math.cos(_omega),
                                  "y": branch_length * Math.sin(_omega)};                
                last_angle = _omega;

                return _step_end;
            }

            function get_next_hotspot_id(_current_pos){
                // calc pos via id

                var _on_grid_x = Math.floor(_current_pos.x / rect_width);
                var _on_grid_y = Math.floor(_current_pos.y / rect_height);

                if (_on_grid_x < 0 ){
                    _on_grid_x = 0
                }
                if (_on_grid_y < 0 ){
                    _on_grid_y = 0
                }
                var _rect_id   = Math.abs(_on_grid_y * cols + _on_grid_x);
                var _x_values, _y_values;

                console.log("Rect:",_rect_id, " X:", _on_grid_x, " Y:", _on_grid_y);
                //console.log("Cols:", cols, " Rows:", rows);
                if (_on_grid_x > 0 && _on_grid_x < cols-1){
                    _x_values = new Array(_on_grid_x -1, _on_grid_x, _on_grid_x +1);
                } else if(_on_grid_x == 0){
                    _x_values = new Array(_on_grid_x, _on_grid_x +1);
                } else if(_on_grid_x >= cols-1){
                    _x_values = new Array(_on_grid_x -1, _on_grid_x);
                }

                if (_on_grid_y > 0 && _on_grid_y < rows-1){
                    _y_values = new Array(_on_grid_y -1, _on_grid_y, _on_grid_y +1);
                } else if(_on_grid_y == 0){
                    _y_values = new Array(_on_grid_y, _on_grid_y +1);
                } else if(_on_grid_y >= rows-1){
                    _y_values = new Array(_on_grid_y -1, _on_grid_y);
                }

                var _hottest_rect_id;
                var _temp_rect_id;
                var _touch_count = 0;
                for (var i = 0; i < _x_values.length; i++){
                    for (var j = 0; j < _y_values.length; j++){
                        _temp_rect_id = _y_values[j] * cols + _x_values[i];
                        if(grid_data[_temp_rect_id].visited < grid_data[_temp_rect_id].touched){
                            if (_touch_count < grid_data[_temp_rect_id].touched){
                                _touch_count = grid_data[_temp_rect_id].touched;
                                _hottest_rect_id = _temp_rect_id;
                            }
                        }
                    }
                }

                if (_touch_count > 0){
                    return _hottest_rect_id;
                } else {
                    return -1;
                }
            }

            function get_random_point_on_rect(rect_id){
                var _point = { "x": randomIntFromInterval(grid_data[rect_id].pos_x, grid_data[rect_id].pos_x + grid_data[rect_id].width),
                               "y": randomIntFromInterval(grid_data[rect_id].pos_y, grid_data[rect_id].pos_y + grid_data[rect_id].height)};
                return _point;
            }

            function get_rect_id_by_pos(point){
                var _on_grid_x = Math.floor(point.x / rect_width);
                var _on_grid_y = Math.floor(point.y / rect_height);
                var _rect_id   = Math.abs(_on_grid_y * cols + _on_grid_x);
                console.log("Rect:",_rect_id, " X:", _on_grid_x, " Y:", _on_grid_y);
                return _rect_id;
            }

            function get_random_angle_by_direction(plant_id, omega, new_dir){
                var _angle = 3*Math.PI/7;
                
                var result_angle = dot_product(normalize_vec(last_direction),normalize_vec(new_dir));
                result_angle = Math.acos(result_angle);
                //console.log ("angle differenz:", result_angle);
                if (result_angle < 0.1){
                    if (plant_id % 2 == 0){
                        result_angle = _angle * Math.random();
                    } else if (plant_id % 2 == 1){
                        result_angle = - _angle * Math.random();
                    }
                } else if (result_angle > 0.61){ 
                    result_angle = _angle * Math.random() - (_angle/2);
                } else {
                    result_angle = 0;
                }
                last_direction = new_dir;    
                return result_angle;
            }

            function start_ageing(){
                while (age_queue.length != 0){
                    idx = age_queue.shift();
                    //console.log("apply ageing",idx);
                    ageing_branch = plant_data[idx];

                    if (ageing_branch.type == "ta"){
                        d3.select("#p"+ageing_branch.id)
                            .transition()
                                .duration(16000)
                                .attr("stroke","rgb(50, 80, 32)")
                                .attr("stroke-width",8);
                    } else if (ageing_branch.type == "la"){
                        d3.select("#p"+ageing_branch.id)
                            .transition()
                                .duration(16000)
                                .attr("stroke","rgb(20, 100, 32)")
                                .attr("stroke-width",4);
                    }else if (ageing_branch.type == "lb"){
                        d3.select("#p"+ageing_branch.id)
                            .transition()
                                .duration(16000)
                                .attr("stroke","rgb(20, 90, 32)")
                                .attr("stroke-width",4);
                    }else if (ageing_branch.type == "lc"){
                        d3.select("#p"+ageing_branch.id)
                            .transition()
                                .duration(16000)
                                .attr("stroke","rgb(30, 50, 12)")
                                .attr("stroke-width",3);
                    }else if (ageing_branch.type == "ld"){
                        d3.select("#p"+ageing_branch.id)
                            .transition()
                                .duration(16000)
                                .attr("stroke","rgb(70, 50, 12)")
                                .attr("stroke-width",3);
                    }

                }
            }

            function randomIntFromInterval(min,max){
                
                return Math.floor(Math.random()*(max-min+1)+min);
            }


            // ##### TREE FUNCTIONS #####
            function init_tree(){
                var _omega =   -Math.PI/2;//max_angle * Math.random() + (max_angle/2) ;
                var _start = { "x":1170/2, 
                               "y":700};
                //var _middle = { "x": _start.x + branch_length * Math.cos(_omega) * 0.5+ 20,
                //                "y": _start.y + (branch_length * Math.sin(_omega) * 0.5)}; 
                var _end = { "x": _start.x + 2.5* tree_length * Math.cos(_omega), 
                             "y": _start.y + 2.5* tree_length * Math.sin(_omega)}; 

                var _root = new Array();
                _root.push(_start);
                //_root.push(_middle)
                _root.push(_end);

                tree_data[0] = new Object();
                tree_data[0]["id"] = 0;
                tree_data[0]["branch"] = _root;
                tree_data[0]["angle"] = _omega;
                tree_data[0]["generation"] = 0;
                tree_data[0]["children"] = [1,2];
                tree_data[0]["parent"] = -1;
                tree_branch_count++;

                tree_queue.push(0);
                draw_tree_branches([0]);
            }

            function create_tree_branches(object){
                for (i in object.children){
                    child = object.children[i];
                    tree_data[child] = new Object();

                    var _old_end = tree_data[object.id].branch[1];
                    var _old_omega = tree_data[object.id].angle;
                    var _omega = _old_omega + Math.random() * Math.PI/2 - (Math.PI/2 / 2); 
                    var _start = { "x": _old_end.x, 
                                   "y": _old_end.y};

                    
                    var _end = {"x": _start.x + tree_length * Math.cos(_omega),
                                "y": _start.y + tree_length * Math.sin(_omega)};
                    

                    var _branch = new Array(_start,_end);

                    tree_data[child]["id"] = child;
                    tree_data[child]["branch"] = _branch;
                    tree_data[child]["angle"] = _omega;
                    tree_data[child]["generation"] = object.generation +1;
                    tree_data[child]["children"] = [child*2+1,child*2+2];
                    tree_data[child]["parent"] = object.id;
                    tree_branch_count++;

                    tree_queue.push(child);
                }
            }

            function draw_tree_branches(branch_list, time){
                var _branch_count = branch_list.length;
                for (var i = 0; i < _branch_count; i++){
                    idx = branch_list.shift();
                    var lineFunction = d3.svg.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; })
                        .interpolate("basis");

                    var plantGraph = treeContainer.append("path")
                        .attr("d", lineFunction(tree_data[idx].branch))
                        .attr("id", "t"+tree_data[idx].id)
                        .attr("stroke", "green")
                        .attr("stroke-width", 8 - (tree_data[idx].generation) * 0.6)
                        .attr("stroke-linecap", "round")  // stroke-linecap type
                        .attr("fill", "none")
                        

                    var plant_length = plantGraph.node().getTotalLength();

                    plantGraph.attr("stroke-dasharray", plant_length + " " + plant_length)
                        .attr("stroke-dashoffset", plant_length)
                        .transition()
                        //.delay(plant_data[idx].generation * 3000)
                            .duration(time)
                            .ease("basis")
                            .attr("stroke-dashoffset", 0);
                }
            }

            function grow_tree(iterations, max_depth){
                if(iterations < max_depth){
                    time = randomIntFromInterval(grow_time-200, grow_time+200)
                    setTimeout(function(){
                        var _l = tree_queue.length;

                        for (var i = 0; i < _l; i++){
                            idx = tree_queue.shift();

                            create_tree_branches(tree_data[idx]); //create children of last branch

                            draw_tree_branches(tree_data[idx].children, time); // draw children of last branch
                        }
                        iterations++;
                        //console.log(iterations);
                        grow_tree(iterations,max_depth);
                    }, time);
                }
            }
            </script>

            
        </div>
    </body>